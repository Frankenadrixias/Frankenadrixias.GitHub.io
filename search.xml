<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python-Dataframe SQL教程</title>
    <url>/homepage/posts/e4bc4527/</url>
    <content><![CDATA[<p>在 Python 中，对<code>pandas.Dataframe</code>进行 SQL 查询主要有两种操作方式，分别为<code>pandas</code>的基本操作语句，以及<code>pandasql</code>库提供的直接对<code>Dataframe</code>进行 SQL 查询的操作。</p>
<span id="more"></span>

<p>虽然 Python 内置了<code>sqlite</code>数据库模块，但是其与<code>Dataframe</code>交互不方便，需要将原始数据插入<code>sqlite</code>后才可以使用 SQL 语句进行查询操作，因此一般还是用上述两种方法来完成 SQL 查询。</p>
<p><code>sqlite</code>的操作流程：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;example.db&#x27;</span>)</span><br><span class="line"><span class="comment"># 连接后创建一个 Cursor 对象并调用其 execute() 方法来执行 SQL 命令</span></span><br><span class="line">c = conn.cursor()</span><br><span class="line"><span class="comment"># 创建表</span></span><br><span class="line">c.execute(<span class="string">&#x27;&#x27;&#x27;CREATE TABLE stocks(date text, trans text, symbol text, qty real, price real)&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加一行数据</span></span><br><span class="line">c.execute(<span class="string">&quot;INSERT INTO stocks VALUES (&#x27;2006-01-05&#x27;,&#x27;BUY&#x27;,&#x27;RHAT&#x27;,100,35.14)&quot;</span>)</span><br><span class="line"><span class="comment"># 保存修改</span></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p><strong>两种方式的优缺点：</strong><br>Pandas 基本操作语句</p>
<ul>
<li>优点：不需要额外安装第三方库，大多数场景内置函数都可以满足需求</li>
<li>缺点：在有些数据处理计算中不如 SQL 语言简洁易读（如大量的<code>.groupby()</code>、<code>.sum()</code>或者<code>.count()</code>之类），且无法实现部分复杂功能</li>
</ul>
<p>Pandasql 库</p>
<ul>
<li>优点：直接使用 SQL 语句完成查询操作，易读性高且可移植性好</li>
<li>缺点：</li>
</ul>
<h2 id="Pandasql-库"><a href="#Pandasql-库" class="headerlink" title="Pandasql 库"></a>Pandasql 库</h2><p><code>pandasql</code>允许您使用 SQL 语法查询<code>pandas.DataFrame</code>。它的工作原理与<code>R.pandasql</code>中的<code>sqldf</code>类似。<code>pandasql</code>试图为刚接触 Python 或<code>pandas</code>的人提供一种更熟悉的操作和清理数据的方法。</p>
<h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pandasql</span><br></pre></td></tr></table></figure>
<p>相关文档：<a href="https://pypi.org/project/pandasql/">https://pypi.org/project/pandasql/</a></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><code>pandasql</code>中使用的主要函数是<code>sqldf</code>。<code>sqldf</code>接受 2 个参数：</p>
<ul>
<li>一个 SQL 查询字符串</li>
<li>一组会话&#x2F;环境变量（<code>locals()</code>或<code>globals()</code>）</li>
</ul>
<p>一般使用时我们会定义一个简短的 lambda 表达式来使用这个函数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandasql <span class="keyword">import</span> sqldf</span><br><span class="line">pysqldf = <span class="keyword">lambda</span> q: sqldf(q, <span class="built_in">globals</span>())</span><br></pre></td></tr></table></figure>

<h3 id="查询实例"><a href="#查询实例" class="headerlink" title="查询实例"></a>查询实例</h3><p><code>pandasql</code>使用 SQLite 语法，将自动检测所有的<code>pandas.DataFrame</code>名称。可以像查询任何常规 SQL 表一样查询它们。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandasql <span class="keyword">import</span> sqldf, load_meat, load_births</span><br><span class="line">pysqldf = <span class="keyword">lambda</span> q: sqldf(q, <span class="built_in">globals</span>())</span><br><span class="line">meat, births = load_meat(), load_births()</span><br><span class="line"><span class="built_in">print</span> pysqldf(<span class="string">&quot;SELECT * FROM meat LIMIT 10;&quot;</span>).head()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">                   date  beef  veal pork  lamb_and_mutton  broilers  other_chicken  turkey</span><br><span class="line"><span class="number">0</span>   <span class="number">1944</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">751</span>    <span class="number">85</span> <span class="number">1280</span>               <span class="number">89</span>      <span class="title class_">None</span>           <span class="title class_">None</span>    <span class="title class_">None</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1944</span>-<span class="number">02</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">713</span>    <span class="number">77</span> <span class="number">1169</span>               <span class="number">72</span>      <span class="title class_">None</span>           <span class="title class_">None</span>    <span class="title class_">None</span></span><br><span class="line"><span class="number">2</span>   <span class="number">1944</span>-<span class="number">03</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">741</span>    <span class="number">90</span> <span class="number">1128</span>               <span class="number">75</span>      <span class="title class_">None</span>           <span class="title class_">None</span>    <span class="title class_">None</span></span><br><span class="line"><span class="number">3</span>   <span class="number">1944</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">650</span>    <span class="number">89</span>  <span class="number">978</span>               <span class="number">66</span>      <span class="title class_">None</span>           <span class="title class_">None</span>    <span class="title class_">None</span></span><br><span class="line"><span class="number">4</span>   <span class="number">1944</span>-<span class="number">05</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">681</span>   <span class="number">106</span> <span class="number">1029</span>               <span class="number">78</span>      <span class="title class_">None</span>           <span class="title class_">None</span>    <span class="title class_">None</span></span><br></pre></td></tr></table></figure>

<p><strong>Where 条件语句：</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">q = <span class="string">&quot;&quot;&quot;SELECT date, veal, lamb_and_mutton</span></span><br><span class="line"><span class="string">       FROM meat</span></span><br><span class="line"><span class="string">       WHERE lamb_and_mutton &gt;= veal</span></span><br><span class="line"><span class="string">       ORDER BY date DESC;&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> pysqldf(q).head()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">                  date  veal  lamb_and_mutton</span><br><span class="line"><span class="number">0</span>  <span class="number">2012</span>-<span class="number">11</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">10.1</span>             <span class="number">12.4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2012</span>-<span class="number">10</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">10.3</span>             <span class="number">14.2</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2012</span>-<span class="number">09</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">8.8</span>             <span class="number">12.5</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2012</span>-<span class="number">08</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">10.1</span>             <span class="number">14.2</span></span><br></pre></td></tr></table></figure>

<p><strong>Join 连接语句：</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">q = <span class="string">&quot;&quot;&quot;SELECT m.date, m.beef, b.births</span></span><br><span class="line"><span class="string">       FROM meats m</span></span><br><span class="line"><span class="string">       INNER JOIN births b</span></span><br><span class="line"><span class="string">       ON m.date = b.date;&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> pysqldf(q).head()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">                    date    beef  births</span><br><span class="line"><span class="number">403</span>  <span class="number">2012</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">2200.8</span>  <span class="number">368450</span></span><br><span class="line"><span class="number">404</span>  <span class="number">2012</span>-<span class="number">08</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">2367.5</span>  <span class="number">359554</span></span><br><span class="line"><span class="number">405</span>  <span class="number">2012</span>-<span class="number">09</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">2016.0</span>  <span class="number">361922</span></span><br><span class="line"><span class="number">406</span>  <span class="number">2012</span>-<span class="number">10</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">2343.7</span>  <span class="number">347625</span></span><br><span class="line"><span class="number">407</span>  <span class="number">2012</span>-<span class="number">11</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">2206.6</span>  <span class="number">320195</span></span><br></pre></td></tr></table></figure>

<p><strong>Aggregation 聚合语句：</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">q = <span class="string">&quot;&quot;&quot;SELECT strftime(&#x27;%Y&#x27;, date) AS year, SUM(beef) AS beef_total</span></span><br><span class="line"><span class="string">       FROM meat</span></span><br><span class="line"><span class="string">       GROUP BY year;&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> pysqldf(q).head()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   year  beef_total</span><br><span class="line"><span class="number">0</span>  <span class="number">1944</span>        <span class="number">8801</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1945</span>        <span class="number">9936</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1946</span>        <span class="number">9010</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1947</span>       <span class="number">10096</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1948</span>        <span class="number">8766</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="no-such-table报错"><a href="#no-such-table报错" class="headerlink" title="no such table报错"></a>no such table报错</h4><p><code>pandasql</code>在执行时是读取在内存中的<code>dataframe</code>名称，因此执行的 SQL 语句一定要放在主程序中，或者将<code>dataframe</code>设为全局变量。</p>
<h4 id="处理不规范的字段名"><a href="#处理不规范的字段名" class="headerlink" title="处理不规范的字段名"></a>处理不规范的字段名</h4><p>当表的名字或列的名字中，含有空格或关键字等一些特殊字符时，我们需要用<code>[]</code>将表名引起来，告诉语法分析器<code>[]</code>号内的才是一个完整的名称。比如<code>SELECT * FROM [Order Details]</code></p>
<h2 id="Pandas-基本操作语句"><a href="#Pandas-基本操作语句" class="headerlink" title="Pandas 基本操作语句"></a>Pandas 基本操作语句</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df=pd.read_csv(<span class="string">&quot;&quot;</span>) <span class="comment">#默认输入csv文件路径</span></span><br><span class="line">df.head() <span class="comment">#读取前5行数据（输入数字就取对应开始的行数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.select操作：select 列名 from 表A limit 5</span></span><br><span class="line">df[[<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>]].head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.where条件：select 列名 from 表名 where 条件=&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 使用括号的方式进行 连接多个条件</span></span><br><span class="line">condition=(df[<span class="string">&quot;列名&quot;</span>]==<span class="string">&quot;&quot;</span>)&amp;(df[<span class="string">&quot;列名&quot;</span>]==<span class="string">&quot;&quot;</span>)&amp;(df[<span class="string">&quot;列名&quot;</span>]==<span class="string">&quot;&quot;</span>)</span><br><span class="line">condition.value_count()</span><br><span class="line">df[condition].head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.in和not in：select * from 表A where 列名 in(&#x27;1&#x27;,&#x27;2&#x27;)</span></span><br><span class="line">df[<span class="string">&quot;列名&quot;</span>].unique()   <span class="comment"># 去重</span></span><br><span class="line"><span class="comment"># in</span></span><br><span class="line">df[df[<span class="string">&quot;列名&quot;</span>].isin((<span class="number">1</span>,<span class="number">2</span>))].head()</span><br><span class="line"><span class="comment"># not in:df取反符号为~</span></span><br><span class="line">df[~df[<span class="string">&quot;列名&quot;</span>].isin((<span class="number">1</span>,<span class="number">2</span>))].head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.1group by：select sum(),maen() from person group by sex</span></span><br><span class="line">df.groupby(<span class="string">&quot;sex&quot;</span>).agg(&#123;列名：np.<span class="built_in">sum</span>,<span class="string">&quot;列名&quot;</span>:np.mean,<span class="string">&quot;列名&quot;</span>:np.mean&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.2.多个列的聚合：select sum（）,mean() from person group by sex,department</span></span><br><span class="line">df.groupby([<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;department&quot;</span>]).agg(&#123;列名：np.<span class="built_in">sum</span>,<span class="string">&quot;列名&quot;</span>:np.mean,<span class="string">&quot;列名&quot;</span>:np.mean&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.join数据关联：select * from table1 a1 join table2 a2 on a1.列名=a2.列名 limit 5</span></span><br><span class="line">df2=pd.read_csv()</span><br><span class="line">df2.head(<span class="number">5</span>)  <span class="comment"># 查看前5行数据</span></span><br><span class="line">df_merged=pd.merge(left=df1,right=df2,on=<span class="string">&quot;列名&quot;</span>)</span><br><span class="line">df_merged.head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.Union数据合并，当两个表的数据列一致时使用union。</span></span><br><span class="line"><span class="comment"># SQL:selet city，rank from 表1 union all select city，，rank from 表2</span></span><br><span class="line"><span class="comment"># 同样的df也需要有相同的列名，假设df1和df2的列名是一致的</span></span><br><span class="line">pd.concat([df1,df2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.order limnit先排序后分页</span></span><br><span class="line"><span class="comment"># sql：select * from 表1 order by 列名 limit 5</span></span><br><span class="line">df.sort_values(<span class="string">&quot;列名&quot;</span>,ascending=<span class="literal">False</span>).head(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.取每个分组group的top n：mysql不支持，oracle使用rownum</span></span><br><span class="line"><span class="comment"># 根据列名1，列名2分组，取列名3的top2</span></span><br><span class="line">df.groupby([<span class="string">&quot;列名1&quot;</span>,<span class="string">&quot;列名2&quot;</span>]).apply(<span class="keyword">lambda</span> df:df.sort_values(<span class="string">&quot;列名3&quot;</span>,ascending=<span class="literal">False</span>).head(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.update数据更新：update 表1 set 列名1=value where 条件</span></span><br><span class="line">df.info() <span class="comment">#查看df的信息</span></span><br><span class="line">condition=df[<span class="string">&quot;列名&quot;</span>].isna()</span><br><span class="line">condition.values_counts()</span><br><span class="line">df[condition]=value</span><br><span class="line">df[<span class="string">&quot;列名&quot;</span>].isna().values_counts()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10.delete删除数据：delete from 表1 where 列名=0</span></span><br><span class="line"><span class="comment"># df取反条件的值付给新的df</span></span><br><span class="line">df_new=df[df[<span class="string">&quot;列名&quot;</span>]!=<span class="number">0</span>]</span><br><span class="line">df_new[df_new[<span class="string">&quot;列名&quot;</span>]=<span class="number">0</span>] <span class="comment">#可以得到0条数据</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_42692386/article/details/113886419">https://blog.csdn.net/qq_42692386&#x2F;article&#x2F;details&#x2F;113886419</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>一些闲聊</title>
    <url>/homepage/posts/933a2506/</url>
    <content><![CDATA[<p>随便写点东西</p>
<h1 id="测试一下一级标题"><a href="#测试一下一级标题" class="headerlink" title="测试一下一级标题"></a>测试一下一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><span id="more"></span>

<p>以后应该会写更多东西吧，主要是先测试一下。</p>
<p>看看能不能写 <em>斜体字</em> 或者 <strong>粗体字</strong> ？</p>
<p>一些个人基本信息在 <b>About</b> 里</p>
<h2 id="列表测试"><a href="#列表测试" class="headerlink" title="列表测试"></a>列表测试</h2><ol>
<li>第1个</li>
<li>第2个<ul>
<li>2.1</li>
<li>2.2</li>
</ul>
</li>
<li>第3个</li>
</ol>
<h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>行内公式： $a + b &#x3D; c$</p>
<p>行间公式：</p>
<p>$$ x &#x3D; \frac{\sqrt{-b \pm b^2-4ac}}{2a} \tag{1} $$</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/homepage/posts/4a17b156/</url>
    <content><![CDATA[<h2 id="Frankenadrixias’Homepage"><a href="#Frankenadrixias’Homepage" class="headerlink" title="Frankenadrixias’Homepage"></a>Frankenadrixias’Homepage</h2><p>欢迎来到 <a href="https://hexo.io/">Hexo</a>！这是你的第一篇文章。查看<a href="https://hexo.io/docs/">文档</a>以了解更多信息。如果你在使用 Hexo 时遇到任何问题，你可以在<a href="https://hexo.io/docs/troubleshooting.html">故障排除</a> 中找到答案，也可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a> 上问我。</p>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<p><a href="https://www.oscs1024.com/project/Frankenadrixias/homepage?ref=badge_small"><img src="https://www.oscs1024.com/platform/badge/Frankenadrixias/homepage.svg?size=small" alt="OSCS Status"></a></p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>安装 nodejs，然后通过 npm 安装 hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装公式渲染器，然后再<a href="https://github.com/jgm/pandoc/blob/main/INSTALL.md">安装 pandoc</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked</span><br><span class="line">npm i hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>

<p>安装图片渲染器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-marked --save</span><br><span class="line">npm i hexo-asset-img --save</span><br></pre></td></tr></table></figure>

<p>启用下列设置，资源图片将会被自动解析为其对应文章的路径。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">marked<span class="punctuation">:</span></span><br><span class="line">  prependRoot<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  postAsset<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">例如：image.jpg 位置为 /2022/01/02/blog-test/image.jpg，</span><br><span class="line">![](image.jpg) 将会被解析为 <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/2022/01/02/blog-test/image.jpg&quot;</span>&gt;</span></span><br><span class="line">同时也可以用html方法：</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span> 将会被解析为 <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/2022/01/02/blog-test/image.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">如果像设置图像的最小缩放宽度，可以用 style 样式：</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.image</span>&#123;<span class="attribute">min-width</span>: <span class="number">600px</span>&#125;    </span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">img</span>&#123;<span class="attribute">object-fit</span>: scale-down&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建公钥，安装 git 部署插件，部署到 github 服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#123;key_name&#125;  </span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p>新建博文 Create a new post <br>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行本地服务器 Run server <br>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>生成静态页面 Generate static files <br>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>部署到远程服务器 Deploy to remote sites <br>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>代码教程与注意事项</title>
    <url>/homepage/posts/c880c6a1/</url>
    <content><![CDATA[<p>代码教程与注意事项</p>
<span id="more"></span>

<hr>
<style>
    img{object-fit: scale-down}
</style>

<h2 id="Markdown-相关"><a href="#Markdown-相关" class="headerlink" title="Markdown 相关"></a>Markdown 相关</h2><p>Markdown 中的公式编辑教程：<a href="https://www.jianshu.com/p/25f0139637b7">https://www.jianshu.com/p/25f0139637b7</a></p>
<h2 id="Python相关"><a href="#Python相关" class="headerlink" title="Python相关"></a>Python相关</h2><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>默认颜色和对应名称：</p>
<img src="img1.png" width="100%" alt="pic1">

<p>常用标记点形状：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;.&#x27;</span>：点(point marker)</span><br><span class="line"><span class="string">&#x27;,&#x27;</span>：像素点(pixel marker)</span><br><span class="line"><span class="string">&#x27;o&#x27;</span>：圆形(circle marker)</span><br><span class="line"><span class="string">&#x27;v&#x27;</span>：朝下三角形(triangle_down marker)</span><br><span class="line"><span class="string">&#x27;^&#x27;</span>：朝上三角形(triangle_up marker)</span><br><span class="line"><span class="string">&#x27;&lt;&#x27;</span>：朝左三角形(triangle_left marker)</span><br><span class="line"><span class="string">&#x27;&gt;&#x27;</span>：朝右三角形(triangle_right marker)</span><br><span class="line"><span class="string">&#x27;1&#x27;</span>：朝下三叉(tri_down marker)</span><br><span class="line"><span class="string">&#x27;2&#x27;</span>：朝下三叉(tri_up marker)</span><br><span class="line"><span class="string">&#x27;3&#x27;</span>：朝下三叉(tri_left marker)</span><br><span class="line"><span class="string">&#x27;4&#x27;</span>：朝下三叉(tri_right marker)</span><br><span class="line"><span class="string">&#x27;s&#x27;</span>：正方形(square marker)</span><br><span class="line"><span class="string">&#x27;p&#x27;</span>：五边形(pentagon marker)</span><br><span class="line"><span class="string">&#x27;*&#x27;</span>：五角星(star marker)</span><br><span class="line"><span class="string">&#x27;h&#x27;</span>：竖直六边形(hexagon1 marker)</span><br><span class="line"><span class="string">&#x27;H&#x27;</span>：水平六边形(hexagon2 marker)</span><br><span class="line"><span class="string">&#x27;+&#x27;</span>：加号(plus marker)</span><br><span class="line"><span class="string">&#x27;x&#x27;</span>：乘号(x marker)</span><br><span class="line"><span class="string">&#x27;D&#x27;</span>：菱形(diamond marker)</span><br><span class="line"><span class="string">&#x27;d&#x27;</span>：小型菱形(thin_diamond marker)</span><br><span class="line"><span class="string">&#x27;|&#x27;</span>：垂直线(vline marker)</span><br><span class="line"><span class="string">&#x27;_&#x27;</span>：水平线(hline marker)</span><br></pre></td></tr></table></figure>

<p>常用线形：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;-&#x27;</span>: 实线(solid line style)</span><br><span class="line"><span class="string">&#x27;--&#x27;</span>: 虚线(dashed line style)</span><br><span class="line"><span class="string">&#x27;-.&#x27;</span>: 点划线(dash-dot line style)</span><br><span class="line"><span class="string">&#x27;:&#x27;</span>: 点线(dotted line style)</span><br></pre></td></tr></table></figure>

<h4 id="绘制变量相关性图"><a href="#绘制变量相关性图" class="headerlink" title="绘制变量相关性图"></a>绘制变量相关性图</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算变量的相关性和p值，展示散点图、直方图和相关系数热力图</span></span><br><span class="line">df_corr = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line">cmap = plt.get_cmap(<span class="string">&#x27;RdBu&#x27;</span>)</span><br><span class="line">new_colors = cmap(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加相关系数和背景颜色</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_corr</span>(<span class="params">x_var, y_var, **kwargs</span>):</span><br><span class="line">    coef, p_val = stats.pearsonr(x_var, y_var)[<span class="number">0</span>], stats.pearsonr(x_var, y_var)[<span class="number">1</span>]  <span class="comment"># 计算相关系数和p值</span></span><br><span class="line">    p_str = <span class="string">&#x27;***&#x27;</span> <span class="keyword">if</span> p_val &lt; <span class="number">0.001</span> <span class="keyword">else</span> <span class="string">&#x27;**&#x27;</span> <span class="keyword">if</span> p_val &lt; <span class="number">0.01</span> <span class="keyword">else</span> <span class="string">&#x27;*&#x27;</span> <span class="keyword">if</span> p_val &lt; <span class="number">0.05</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    label = <span class="string">&#x27;&#123;0:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(coef) + <span class="string">&#x27;\n&#x27;</span> + p_str  <span class="comment"># 添加标签</span></span><br><span class="line">    color = <span class="built_in">tuple</span>(new_colors[<span class="built_in">int</span>((<span class="built_in">round</span>(coef, <span class="number">3</span>) + <span class="number">1</span>) * <span class="number">1000</span>)])  <span class="comment"># 计算并添加颜色</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    ax.annotate(label, xy=(<span class="number">0.3</span>, <span class="number">0.3</span>), size=<span class="number">24</span>, xycoords=ax.transAxes)</span><br><span class="line">    ax.patch.set_facecolor(color)  <span class="comment"># 设置 ax 区域背景颜色</span></span><br><span class="line">    ax.patch.set_alpha(<span class="number">0.7</span>)  <span class="comment"># 设置 ax 区域颜色透明度</span></span><br><span class="line"></span><br><span class="line">pg = sns.PairGrid(data=df_corr, height=<span class="number">2</span>)</span><br><span class="line">pg.map_lower(sns.regplot, color=<span class="string">&#x27;k&#x27;</span>, ci=<span class="number">95</span>, scatter_kws=&#123;<span class="string">&#x27;s&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;lw&#x27;</span>: <span class="number">0.3</span>, <span class="string">&#x27;alpha&#x27;</span>: <span class="number">0.6</span>&#125;,</span><br><span class="line">             line_kws=&#123;<span class="string">&#x27;lw&#x27;</span>: <span class="number">2</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&#x27;firebrick&#x27;</span>&#125;)  <span class="comment"># scatter, regplot, histplot, kdeplot</span></span><br><span class="line">pg.map_diag(sns.histplot, bins=<span class="number">10</span>, edgecolor=<span class="string">&#x27;w&#x27;</span>, kde=<span class="literal">True</span>, line_kws=&#123;<span class="string">&#x27;lw&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">pg.map_upper(draw_corr)</span><br><span class="line">pg.tight_layout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置子图的标签字体大小</span></span><br><span class="line">PairGrid_axes = pg.axes</span><br><span class="line"><span class="keyword">for</span> axes <span class="keyword">in</span> PairGrid_axes.flatten():</span><br><span class="line">    axes.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">16</span>)</span><br><span class="line">    axes.ticklabel_format(style=<span class="string">&#x27;sci&#x27;</span>, scilimits=(-<span class="number">1</span>, <span class="number">2</span>), axis=<span class="string">&#x27;both&#x27;</span>)</span><br><span class="line">    axes.xaxis.label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    axes.yaxis.label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="Opencv-python"><a href="#Opencv-python" class="headerlink" title="Opencv-python"></a>Opencv-python</h3><p>由于 imwrite 使用编码在 python3 中已经不适用，可用 imencode 代替</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># img_path为读取图片路径，save_path为保存图片路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片：若路径有中文则imread方法不成功，imdecode可以读取包含中文的路径</span></span><br><span class="line">im = cv2.imread(img_path, <span class="number">1</span>)</span><br><span class="line">img = cv2.imdecode(np.fromfile(img_path, dtype=np.uint8), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图片：若路径有中文则该imread方法不成功，imdecode可以保存包含中文的路径，&#x27;.jpg&#x27;为保存文件格式</span></span><br><span class="line">cv2.imwrite(save_path, img)</span><br><span class="line">cv2.imencode(<span class="string">&#x27;.jpg&#x27;</span>, img)[<span class="number">1</span>].tofile(save_path)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>CMIP6数据下载相关</title>
    <url>/homepage/posts/b9f1380d/</url>
    <content><![CDATA[<p>最近的研究有关于CMIP6，其中在数据下载方面有很多需要注意的点，本文将系统性的介绍一下。</p>
<span id="more"></span>

<hr>
<style>
    img{object-fit: scale-down}
</style>

<h2 id="数据背景介绍"><a href="#数据背景介绍" class="headerlink" title="数据背景介绍"></a>数据背景介绍</h2><p>CMIP6，即第6次国际耦合模式比较计划（Coupled Model Inter-comparison Project, CMIP），是由世界气候研究计划耦合模拟工作组（WGCM）发起和组织。其最初目的是对当时数量有限的全球耦合气候模式的模拟性能进行比较。但此后全球海-气耦合模式进入了快速发展阶段，全球各大气候模拟中心相继发布大量的大气和海洋模拟数据。因此，产生了对这些模拟结果进行系统分析的需求。为适应这一需求，CMIP 逐渐发展成为以“推动模式发展和增进对地球气候系统的科学理解”为目标的庞大计划。</p>
<p>1995年，WGCM 发起和组织了 AMIP 计划，对当时数量有限的全球耦合气候模式的性能进行比较。此后，全球海气耦合模式进入了快速发展阶段，模式数量迅速增加，模式数据爆发式增长。全球各大气候模拟中心相继发布大量的大气和海洋模拟数据，科学界迫切需要有专门的组织对这些模拟结果进行系统的分析。为适应这一需求，CMIP 逐渐发展成为以“推动模式发展和增进对地球气候系统的科学理解”为目标的庞大计划。为了实现该目标，CMIP 在设计气候模式试验标准、制定共享数据格式、制定向全球科学界共享气候模拟数据的机制等方面开展了卓有成效的工作。</p>
<p>WGCM 设立了两个工作小组：一是 CMIP 工作组（CMIP Panel），直接负责 CMIP 的组织协调工作；二是 WGCM 基础设施工作组（Infrastructure Panel），负责制定模式数据共享政策和技术标准。CMIP 试验数据通过地球系统网格联盟（Earth System Grid Federation，ESGF）面向国际科学界提供。</p>
<p>CMIP6 计划介绍：<a href="https://pcmdi.llnl.gov/CMIP6/">https://pcmdi.llnl.gov/CMIP6/</a> <br>CMIP6 数据下载地址：<a href="https://esgf-node.llnl.gov/search/cmip6/">https://esgf-node.llnl.gov/search/cmip6/</a> <br>建议使用英国源：<a href="https://esgf-index1.ceda.ac.uk/search/cmip6-ceda/">https://esgf-index1.ceda.ac.uk/search/cmip6-ceda/</a> (2023.11.01更新：现在英国源似乎有问题不让下载，还是走官方地址吧)</p>
<h2 id="数据筛选"><a href="#数据筛选" class="headerlink" title="数据筛选"></a>数据筛选</h2><p>CMIP6 各变量及对应缩写介绍：<a href="https://clipc-services.ceda.ac.uk/dreq/mipVars.html">https://clipc-services.ceda.ac.uk/dreq/mipVars.html</a> <br>可以通过输入关键词搜索自己想要的变量的缩写，或者在官网下载缩写对应表的 excel 文件。</p>
<img src="img.png" width="30%" alt="pic1">

<p>这里对一般情况下，我们用到的检索条件做个简要的介绍</p>
<p>MIP Era：即 MIP 代际数，这里只有一个可选，即最新的 MIP6；<br>Activity：项目计划；<br>Product：研究产品，即模型输出，这里依旧是只有一个 model-output 可选；</p>
<p>Source ID：各种评估模式的名称，CMIP6 有 9 个模式来自中国；<br>Institution ID：各个评估机构的名称；<br>Source Type：数据源类型，一般是某种大气动力学模型；<br>Nominal Resolution：空间分辨率，一般有 100km、250km 等；</p>
<p>Experiment ID：研究的实验场景，如历史模拟(historical)，各种 ssp 情景等等；<br>Sub-Experiment：子实验名称；<br>Variant Label：变量标签，一般选 r1i1p1f1；<br>Grid Label：网格标签，一般选 gn，即原始网格；</p>
<p>Table ID：研究的时间尺度代码；<br>Frequency：研究的时间尺度，如日尺度、月尺度，小时尺度等等；<br>Realm：数据领域，如 atmos 代表大气；<br>Variable：研究的变量，如降雨、降雪、均温等等；<br>CF Standard Name：变量的标准名称；</p>
<p>Data Node：数据节点，即数据来源。</p>
<ul>
<li>其中，ssp 后面的数字含义为<strong>共享的社会经济路径</strong> (Shared Socioeconomic Pathways, SSP) + <strong>代表性浓度路径</strong> (Representative Concentration Pathways, RCP)。</li>
<li>举例来说，ssp245 指的是在 ssp2 路径下（即“中间路线”世界），温室气体等辐射强迫控制在 $4.5W&#x2F;m^2$ 的情景</li>
</ul>
<p><strong>一般来说，选了以上三个检索条件后，就可以点击search了。</strong><br>在结果中再点击 Source ID，查看有哪些模型符合这个检索条件。需根据实际情况进行调整。<br>注意：有的时候 search 会显示没有对应文件或者文件失效，这个时候可以把 Show All Replicas 选中再 search 就有文件了。</p>
<img src="img1.png" width="100%" alt="pic2">

<p>根据需求筛选好条目之后，点开所有条目的 List Files，可以看到每一个对应文件的文件名、checksum 值、文件大小以及 id 号，还有最重要的下载链接。</p>
<img src="img2.png" width="100%" alt="pic3">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">条目命名规则：&#123;MIP_Era&#125;.&#123;Activity&#125;.&#123;Institution_ID&#125;.&#123;Source_ID&#125;.&#123;Experiment_ID&#125;.&#123;Variant_Label&#125;.&#123;Table_ID&#125;.&#123;Variable&#125;.&#123;Grid_Label&#125;</span><br><span class="line">文件命名规则：&#123;Variable&#125;_&#123;Table_ID&#125;_&#123;Source_ID&#125;_&#123;Experiment_ID&#125;_&#123;Variant_Label&#125;_&#123;Grid_Label&#125;_&#123;Time&#125;.nc</span><br></pre></td></tr></table></figure>

<h2 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h2><p>一般来说 CMIP6 的数据都是 .nc 文件，且大多都需要连续下载很多的文件，这时候可以使用两个工具：\</p>
<ul>
<li>第一个是 Simple Mass Downloader，这是一个浏览器插件，可以实现网页内的下载链接的查找与筛选，也可以实现链接的批量下载 \<br><a href="https://microsoftedge.microsoft.com/addons/detail/simple-mass-downloader/dbhdfkiddhdhmcikjdgblfjbenjfjlfh">Microsoft Edge 链接</a><br><a href="https://chrome.google.com/webstore/detail/simple-mass-downloader/abdkkegmcbiomijcbdaodaflgehfffed">Google Chrome 链接</a></li>
<li>第二个是 <a href="https://eternallybored.org/misc/wget/">Wget</a>，这个工具可以实现批量下载一个 .txt 文件中的所有下载链接，且具有断点续传功能，非常实用。</li>
</ul>
<p>在上述筛选和全部条目 List File 步骤完成以后（<strong>文件多的条目一定要点击 Show All Files</strong>），点击浏览器的 Simple mass downloader 插件，依次执行下图中的6个步骤，即可得到⼀个包含本页所有下载链接的 txt 文件并保存到本地。</p>
<img src="img3.png" width="75%" alt="pic4">
<img src="img4.png" width="100%" alt="pic5">

<p>之后使用 Wget 批量下载文件，打开命令行输入指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c -i C:/Users/Lenovo/Downloads/ssp245-day-tasmax.txt -P E:/Data/cmip6/ssp245-day-tasmax --no-check-certificate</span><br></pre></td></tr></table></figure>
<p>其含义是按照 “C:&#x2F;Users&#x2F;Lenovo&#x2F;Downloads&#x2F;ssp245-day-tasmax.txt” 中的下载链接，将文件下载到文件夹 “E:&#x2F;Data&#x2F;cmip6&#x2F;ssp245-day-tasmax” 中，同时不检查网站证书。</p>
<p>Wget的常用命令可参考：<a href="https://hscyber.github.io/posts/a53b1b2b">https://hscyber.github.io/posts/a53b1b2b</a></p>
<h2 id="数据读取与处理"><a href="#数据读取与处理" class="headerlink" title="数据读取与处理"></a>数据读取与处理</h2><p>根据给定空间范围&#x2F;坐标数据提取 nc 文件中的数据到 pickle 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xarray <span class="keyword">as</span> xr</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据给定空间范围 / 坐标数据提取nc文件（L0级）中的数据到 pickle 文件（L1级）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">L0_extract</span>(<span class="params">nc_folder: <span class="built_in">str</span>, lat: <span class="built_in">list</span>, lon: <span class="built_in">list</span>, out_folder: <span class="built_in">str</span>, method: <span class="built_in">str</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据提取到本地保存</span></span><br><span class="line">    nc_file_col = glob.glob(nc_folder + <span class="string">&#x27;/*.nc&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> nc_file <span class="keyword">in</span> nc_file_col:</span><br><span class="line"></span><br><span class="line">        t1 = time.time()    <span class="comment"># 计时</span></span><br><span class="line">        infile_name = nc_file[nc_file.rfind(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>:nc_file.rfind(<span class="string">&#x27;.&#x27;</span>)]   <span class="comment"># 输入输出文件</span></span><br><span class="line">        outfile_name = out_folder + <span class="string">&#x27;\\&#x27;</span> + infile_name + <span class="string">&#x27;_CN.zip&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> outfile_name <span class="keyword">in</span> glob.glob(out_folder + <span class="string">&#x27;/*.zip&#x27;</span>):     <span class="comment"># 跳过已经完成的文件</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        dx = xr.open_dataset(nc_file)</span><br><span class="line">        dx[<span class="string">&#x27;time&#x27;</span>] = dx[<span class="string">&#x27;time&#x27;</span>].dt.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="comment"># 日期</span></span><br><span class="line">        df = dx.to_dataframe()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按经纬度范围和时间范围检索数据</span></span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">&#x27;by_region&#x27;</span>:   <span class="comment"># 根据给定空间范围</span></span><br><span class="line">            region_cond = <span class="string">&#x27;lat &gt;= &#x27;</span> + <span class="built_in">str</span>(lat[<span class="number">0</span>]) + <span class="string">&#x27; and lat &lt;= &#x27;</span> + <span class="built_in">str</span>(lat[<span class="number">1</span>]) + \</span><br><span class="line">                          <span class="string">&#x27; and lon &gt;=&#x27;</span> + <span class="built_in">str</span>(lon[<span class="number">0</span>]) + <span class="string">&#x27; and lon &lt;= &#x27;</span> + <span class="built_in">str</span>(lon[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># 根据给定坐标数据</span></span><br><span class="line">            region_cond = <span class="string">&#x27;lat == &#x27;</span> + <span class="built_in">str</span>(lat[<span class="number">0</span>]) + <span class="string">&#x27; and lon ==&#x27;</span> + <span class="built_in">str</span>(lon[<span class="number">1</span>])</span><br><span class="line">        df_sel = df.query(region_cond).copy()</span><br><span class="line"></span><br><span class="line">        df_sel.to_pickle(outfile_name)  <span class="comment"># 导出为pickle文件</span></span><br><span class="line">        gc.collect()</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(infile_name, <span class="string">&#x27;costs &#123;0:.2f&#125; minutes&#x27;</span>.<span class="built_in">format</span>((t2 - t1) / <span class="number">60</span>))</span><br></pre></td></tr></table></figure>

<p>根据 pickle 数据文件，按给定时空条件提取数据到 csv 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> scipy.interpolate <span class="keyword">import</span> griddata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据L1级数据文件，按给定时空条件提取数据到csv文件（L2级）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">L1_extract</span>(<span class="params">in_folder, out_folder, point_file, var_name</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定筛选时间范围</span></span><br><span class="line">    sel_date_range = pd.date_range(<span class="string">&#x27;2015-01-01&#x27;</span>, <span class="string">&#x27;2050-12-31&#x27;</span>).astype(<span class="built_in">str</span>).to_list()</span><br><span class="line">    gdf_pnt = gpd.read_file(point_file)[[<span class="string">&#x27;city_code&#x27;</span>, <span class="string">&#x27;city_name&#x27;</span>, <span class="string">&#x27;geometry&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取数据</span></span><br><span class="line">    <span class="keyword">for</span> folder_name <span class="keyword">in</span> os.listdir(in_folder):</span><br><span class="line">        </span><br><span class="line">        folder_path = os.path.join(in_folder, folder_name)  <span class="comment"># 进入模型子目录</span></span><br><span class="line">        df_all = pd.DataFrame([])       <span class="comment"># 每一个目录保存为一个dataframe</span></span><br><span class="line">        <span class="keyword">for</span> f_name <span class="keyword">in</span> glob.glob(folder_path + <span class="string">&#x27;/*.zip&#x27;</span>)[:]:</span><br><span class="line"></span><br><span class="line">            length = <span class="built_in">len</span>(var_name) + <span class="number">5</span>  <span class="comment"># 字符串匹配提取模型名称</span></span><br><span class="line">            model = f_name[f_name.rfind(var_name + <span class="string">&#x27;_day_&#x27;</span>) + length:]</span><br><span class="line">            model = model[:model.find(<span class="string">&#x27;_&#x27;</span>)]</span><br><span class="line">            </span><br><span class="line">            df = pd.read_pickle(f_name)[[var_name]]     <span class="comment"># 读取pickle文件</span></span><br><span class="line">            sel_bnds = df.index.get_level_values(<span class="string">&#x27;bnds&#x27;</span>).unique()[<span class="number">0</span>]</span><br><span class="line">            df = df.xs(sel_bnds, level=<span class="string">&#x27;bnds&#x27;</span>)</span><br><span class="line">            date_range = df.index.get_level_values(<span class="string">&#x27;time&#x27;</span>).unique()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 匹配在筛选时间内的数据</span></span><br><span class="line">            <span class="keyword">for</span> days <span class="keyword">in</span> sel_date_range:</span><br><span class="line">                <span class="keyword">if</span> days <span class="keyword">in</span> date_range:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;Processing:&#x27;</span>, <span class="built_in">str</span>(model), <span class="built_in">str</span>(days))</span><br><span class="line">                    df_day = df.xs(days, level=<span class="string">&#x27;time&#x27;</span>).reset_index()</span><br><span class="line">                    pnt_val = griddata(df_day.loc[:, [<span class="string">&#x27;lon&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>]].to_numpy(),</span><br><span class="line">                                       df_day[var_name].to_list(),</span><br><span class="line">                                       (gdf_pnt.geometry.x.to_list(), gdf_pnt.geometry.y.to_list()),</span><br><span class="line">                                       method=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">                    </span><br><span class="line">                    df_out = pd.DataFrame([])   <span class="comment"># 设置临时dataframe存储数据</span></span><br><span class="line">                    df_out[<span class="string">&#x27;city_code&#x27;</span>] = gdf_pnt.city_code</span><br><span class="line">                    df_out[var_name + <span class="string">&#x27;_&#x27;</span> + model] = pnt_val</span><br><span class="line">                    df_out[<span class="string">&#x27;date&#x27;</span>] = days</span><br><span class="line">                    df_all = pd.concat([df_all, df_out])    <span class="comment"># dataframe拼接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置保存路径及文件名，保存为csv文件</span></span><br><span class="line">        out_path = os.path.join(out_folder, var_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_path):</span><br><span class="line">            os.mkdir(out_path)</span><br><span class="line">        out_file = os.path.join(out_path, var_name + <span class="string">&#x27;_&#x27;</span> + folder_name + <span class="string">&#x27;.csv&#x27;</span>)</span><br><span class="line">        df_all.to_csv(out_file, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h2 id="其他相关教程及参考资料"><a href="#其他相关教程及参考资料" class="headerlink" title="其他相关教程及参考资料"></a>其他相关教程及参考资料</h2><p>CMIP6 简介与数据工具 ACCCMIP6 介绍：<a href="https://zhuanlan.zhihu.com/p/599843527">https://zhuanlan.zhihu.com/p/599843527</a></p>
<p><strong>参考文献：</strong><br>王磊, 包庆, 何编. CMIP6 高分辨率模式比较计划（HighResMIP）概况与评述[J]. 气候变化研究进展, 2019, 15(5): 498-502.<br>DOI: 10.12006&#x2F;j.issn.1673-1719.2019.077<br>周天军, 邹立维, 陈晓龙. 第六次国际耦合模式比较计划(CMIP6)评述[J]. 气候变化研究进展, 2019, 15(05): 445-456.</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>多元回归分析</title>
    <url>/homepage/posts/4ba92e57/</url>
    <content><![CDATA[<p>最近上时空数据分析与建模课，重新学习了一下多元线性回归分析的内容，计划在此做一个梳理，整理一下完整的流程与注意事项。</p>
<span id="more"></span>

<hr>
<h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><h4 id="1、多元线性回归的相关概念"><a href="#1、多元线性回归的相关概念" class="headerlink" title="1、多元线性回归的相关概念"></a>1、多元线性回归的相关概念</h4><p>在客观世界中普遍存在着变量和变量之间的关系，某一些关系是非确定性的，即无法用函数关系直接表达，但是其往往存在高度相关性，比如人的身高和体重，身高较高的人往往体重也较重。回归分析可以帮助我们从一个&#x2F;组变量（自变量，用 $X$ 表示）的取值来估计另一个变量（因变量，用 $Y$ 表示）的值。</p>
<p>在实际问题中，随机变量 $Y$ 往往与多个普通变量 $x_1,x_2,…,x_p ,(p&gt;1)$ 有关。对于自变量 $x_1,x_2,…,x_p$ 的一组确定的值，$Y$ 有它的分布。我们可以用 $F(Y \vert x_1,x_2,…,x_p)$ 来表示当 $x_1,x_2,…,x_p$ 取确定值时，所对应的 $Y$ 的分布函数。</p>
<p>如果能够发掘 $F(Y \vert x_1,x_2,…,x_p)$ 随 $x_1,x_2,…,x_p$ 取值的变化规律，就可以完全确定 $Y$ 和 $X$ 之间的关系。然而上述步骤往往非常复杂，为了简化计算，我们可以做一种近似，去考察 $Y$ 的数学期望 $E(Y)$。即若 $Y$ 的数学期望存在，则其值随 $x_1,x_2,…,x_p$ 的取值而定，因而它是 $x_1,x_2,…,x_p$ 的函数，记为 $\mu_{Y \vert x_1,x_2,…,x_p}$ 或 $\mu(x_1,x_2,…,x_p)$ 即为 $Y$ 关于 $x$ 的回归函数，从而将讨论 $Y$ 和 $X$ 之间的相关关系问题转化为讨论 $E(Y) &#x3D; \mu(x_1,x_2,…,x_p)$ 与 $x_1,x_2,…,x_p$ 的函数关系问题。</p>
<p>当 $\mu (x_1,x_2,…,x_p)$ 是 $x_1,x_2,…,x_p$ 的线性函数时，有：</p>
<p>$$ Y &#x3D; b_0 + b_1x_1 + … + b_px_p + \epsilon, , \epsilon \sim N(0, \sigma^2) \tag{1} $$</p>
<p>其中 $b_0,b_1,…,b_p, \sigma^2$ 均为与 $x_1,x_2,…,x_p$ 无关的未知参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>jekyll搭建个人主页</title>
    <url>/homepage/posts/df9e0963/</url>
    <content><![CDATA[<p>Jekyll 搭建个人主页的步骤与注意事项。</p>
<p>之前我的个人主页是基于 Jekyll + minimal 模板搭建的，23年10月改为了 Hexo + NexT。这里把之前用 jekyll 搭建个人网站的步骤与注意事项重新写一下，大家如果有需求可以自行查阅。</p>
<span id="more"></span>

<hr>
<h2 id="Jekyll的官方介绍"><a href="#Jekyll的官方介绍" class="headerlink" title="Jekyll的官方介绍"></a>Jekyll的官方介绍</h2><p>You’ll find this post in your <code>_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code>jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.<br>您可以在 <code>_posts</code> 目录中找到这篇文章。继续编辑并重新构建网站以查看您的更改。你可以用很多不同的方式重建网站，但最常见的方式是运行 <code>jekyll serve</code>，它启动一个 web 服务器，并在文件更新时自动重新生成你的网站。</p>
<p>To add new posts, simply add a file in the <code>_posts</code> directory that follows the convention <code>YYYY-MM-DD-name-of-post.ext</code> and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.<br>要添加新的帖子，只需在 <code>_posts</code> 目录中添加一个文件，该文件遵循惯例 <code>YYYY-MM-DD-name-of-post.ext</code>，并包含必要的前置内容。看看这篇文章的来源，了解一下它是如何工作的。</p>
<p>Jekyll also offers powerful support for code snippets. It uses Rouge by default for syntax highlighting, here are some tests.<br>Jekyll 还提供了对代码片段的强大支持。默认情况下，它使用 Rouge 进行语法高亮显示，下面是一些测试。（为了符合现有的框架，改用了 Hexo 的高亮显示模板）</p>
<p><strong>Ruby</strong> with line numbers:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_hi</span>(<span class="params">name</span>)</span><br><span class="line">  puts <span class="string">&quot;Hi, <span class="subst">#&#123;name&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">print_hi(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="comment">#=&gt; prints &#x27;Hi, Tom&#x27; to STDOUT.</span></span><br></pre></td></tr></table></figure>

<p><strong>Python</strong> with line numbers:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_hi</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi, &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line">print_hi(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="comment"># prints &#x27;Hi, Tom&#x27; to STDOUT.</span></span><br></pre></td></tr></table></figure>

<p><strong>C</strong> with line numbers:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_hi</span><span class="params">(<span class="built_in">string</span> name)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hi, %s&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">print_hi(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="comment">/* prints &#x27;Hi, Tom&#x27; to STDOUT. */</span></span><br></pre></td></tr></table></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs&#x2F;feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>. <br>查看 <a href="https://jekyllrb.com/docs/home">Jekyll 文档</a> 了解更多关于如何充分利用 Jekyll 的信息。在 Jekyll 的 <a href="https://github.com/jekyll/jekyll">GitHub repo</a> 中提交所有错误&#x2F;功能请求。如果你有问题，可以在 <a href="https://talk.jekyllrb.com/">Jekyll Talk</a> 上提问。</p>
<h2 id="Jekyll-Matjek-模板"><a href="#Jekyll-Matjek-模板" class="headerlink" title="Jekyll Matjek 模板"></a>Jekyll Matjek 模板</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul>
<li>Google Analytics</li>
<li>Disqus</li>
<li><a href="https://shawnteoh.github.io/matjek/projects/">GitHub project page</a></li>
<li><a href="https://shawnteoh.github.io/matjek/tags/">Tags</a> and <a href="https://shawnteoh.github.io/matjek/categories/">Categories</a></li>
<li>Modular CSS and JS includes (<a href="https://github.com/ShawnTeoh/matjek/blob/gh-pages/projects.md/">example</a>)</li>
<li><a href="https://shawnteoh.github.io/matjek/about">Fancy “About” page</a></li>
</ul>
<h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>Clone or fork this repo and edit <code>_config.yml</code> as needed.<br>根据需要克隆或分支此 repo 并编辑 _config.yml。</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>Most of the configurations can be found in <code>_config.yml</code>. The configurations listed below are specific to MatJek. If you are not using <code>google_tracking_id</code> or <code>disqus_shortname</code>, just remove them completely. <br>大多数配置可以在 <code>_config.yml</code> 中找到。下面列出的配置是 MatJek 特有的。如果您没有使用<code>google_tracking_id</code> 或 <code>disqus_shortname</code>，只需将它们完全删除即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_profile:</span> <span class="string">&quot;github_profile_url&quot;</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">&quot;your_name&quot;</span> <span class="comment"># Appears at sidebar</span></span><br><span class="line"><span class="attr">user_email:</span> <span class="string">&quot;your_email&quot;</span> <span class="comment"># Appears at sidebar, remove whole variable if unwanted</span></span><br><span class="line"><span class="attr">contact_url:</span> <span class="string">&quot;google_form_link&quot;</span></span><br><span class="line"><span class="attr">google_tracking_id:</span> <span class="string">&quot;google_analytics_ID&quot;</span></span><br><span class="line"><span class="attr">disqus_shortname:</span> <span class="string">&quot;shortname_given_by_Disqus&quot;</span></span><br></pre></td></tr></table></figure>

<p>Edit the images in <code>assets/res</code> to suit your liking, but try to stick to the original resolutions. If you would like to enable comments in a post (disqus_shortname must be provided), add this line to the front matter of the post.<br>编辑 <code>assets/res</code> 中的图像以满足您的喜好，但尽量保持原始分辨率。如果你想在帖子中启用评论（必须提供disqus_shortname），请将这一行添加到帖子的首页。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Add tags and categories to your posts in the front matter as well. Multiple tags&#x2F;categories can be assigned but need to be separated by spaces.<br>在文章的前面添加标签和类别。可以指定多个标记&#x2F;类别，但需要用空格分隔。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span> <span class="string">default</span> <span class="string">default2</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">test</span> <span class="string">test2</span></span><br></pre></td></tr></table></figure>

<h3 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h3><p>Bug reports and pull requests are welcomed on GitHub at <a href="https://github.com/shawnteoh/matjek">https://github.com/shawnteoh/matjek</a>. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the <a href="http://contributor-covenant.org/">Contributor Covenant</a> code of conduct.<br>GitHub 上欢迎 Bug 报告和拉取请求，网址为 <a href="https://github.com/shawnteoh/matjek">https://github.com/shawnteoh/matjek</a> .该项目旨在成为一个安全、受欢迎的合作空间，参与者应遵守<a href="http://contributor-covenant.org/">《参与者公约》</a>的行为准则。</p>
<h3 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h3><p>To set up your environment to develop this theme, clone&#x2F;fork the repo and run <code>bundle install</code>.<br>To test your theme, run <code>bundle exec jekyll serve</code> and open your browser at <code>http://localhost:4000/matjek/</code>. This starts a Jekyll server using your theme. Add pages, documents, data, etc. like normal to test your theme’s contents. As you make modifications to your theme and to your content, your site will regenerate and you should see the changes in the browser after a refresh, just like normal.<br>要设置环境以开发此主题，请克隆&#x2F;分支 repo 并运行 <code>bundle install</code>。<br>要测试您的主题，请运行 <code>bundle exec jekyll serve</code> 并在浏览器中启动 <a href="http://localhost:4000/matjek/">http://localhost:4000/matjek/</a> .这将使用您的主题启动 Jekyll 服务器。像往常一样添加页面、文档、数据等来测试主题的内容。当你修改你的主题和内容时，你的网站会重新生成，你应该在刷新后在浏览器中看到更改，就像正常情况一样。</p>
<h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><p>The theme is available as open source under the terms of the <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPL v3 License</a>.</p>
<h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><ul>
<li><a href="http://materializecss.com/">Materialize.css</a></li>
<li><a href="https://github.com/btmills/geopattern/">GeoPattern</a></li>
<li><a href="https://daneden.github.io/animate.css/">Animate.css</a></li>
<li><a href="http://morphext.fyianlai.com/">Morphtext</a></li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="https://github.com/DONGChuan/Yummy-Jekyll/">https://github.com/DONGChuan/Yummy-Jekyll/</a></li>
<li><a href="https://github.com/codinfox/codinfox-lanyon/">https://github.com/codinfox/codinfox-lanyon/</a></li>
</ul>
<hr>
<h2 id="Jekyll安装"><a href="#Jekyll安装" class="headerlink" title="Jekyll安装"></a>Jekyll安装</h2><p>jekyll相当于一个编译工具，安装好jekyll后可以创建一个网站模板，通过 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a> 访问网站。</p>
<p>利用jekyll可以实时修改刚刚创建的模板里的内容，并可以实时通过本地url预览改动后的效果。<br>预览完成后，将博客推送到代码仓库里，再通过 <a href="https://frankenadrixias.github.io/">https://frankenadrixias.github.io/</a> 就可以访问到博客里面的内容了。<br>有了 Jekyll，可以不用每次改动一点点就把代码推送到仓库中进行预览，而是本地就可以预览。<br>GitHub 支持 jekyll，hexo等语法解析。</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p><strong>Windows 下的 jekyll 安装步骤：</strong></p>
<p>1、首先安装 <a href="https://rubyinstaller.org/downloads/">Ruby installer</a>，<strong>版本选择3.1.x（更高版本目前有不兼容情况！）</strong><br>按提示安装即可，除了路径以外可以一律默认，注意安装路径中不能有空格！</p>
<p>检查是否成功安装：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure>

<p>2、安装完成后会弹出一个窗口，此时输入3，再按回车。<br>打开命令行执行：</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果在本地构建 jekyll 项目，执行 <code>bundle exec jekyll serve</code> 时遇到以下报错情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GitHub Metadata: No GitHub API authentication could be found. Some fields may be missing or have incorrect data.</span><br><span class="line">Liquid Exception: SSL_connect returned=1 errno=0 peeraddr=[::1]:443 state=error: certificate verify failed (unable to get <span class="built_in">local</span> issuer certificate) <span class="keyword">in</span> projects.md</span><br></pre></td></tr></table></figure>

<p>请检查自己的所有代理&#x2F;梯子&#x2F;vpn，确保关闭后再重新执行 <code>bundle exec jekyll serve</code><br>成功执行后的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Documents\PycharmProjects\Frankenadrixias&gt;bundle <span class="built_in">exec</span> jekyll serve</span><br><span class="line">Configuration file: D:/Documents/PycharmProjects/Frankenadrixias/_config.yml</span><br><span class="line">To use retry middleware with Faraday v2.0+, install `faraday-retry` gem</span><br><span class="line">            Source: D:/Documents/PycharmProjects/Frankenadrixias</span><br><span class="line">       Destination: D:/Documents/PycharmProjects/Frankenadrixias/_site</span><br><span class="line"> Incremental build: disabled. Enable with --incremental</span><br><span class="line">      Generating...</span><br><span class="line">       Jekyll Feed: Generating feed <span class="keyword">for</span> posts</span><br><span class="line">   GitHub Metadata: No GitHub API authentication could be found. Some fields may be missing or have incorrect data.</span><br><span class="line">                    <span class="keyword">done</span> <span class="keyword">in</span> 2.42 seconds.</span><br><span class="line"> Auto-regeneration: enabled <span class="keyword">for</span> <span class="string">&#x27;D:/Documents/PycharmProjects/Frankenadrixias&#x27;</span></span><br><span class="line">    Server address: http://127.0.0.1:4000/homepage/</span><br><span class="line">  Server running... press ctrl-c to stop.</span><br></pre></td></tr></table></figure>

<p>此时在浏览器内输入网址 <code>http://127.0.0.1:4000/homepage/</code> 就可以在本地预览 jekyll 的构建结果了，同时可以更新本地内容，在浏览器端刷新即可。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>轨迹停留点算法思路</title>
    <url>/homepage/posts/e3e98ef4/</url>
    <content><![CDATA[<p>介绍一下轨迹停留点提取的相关算法</p>
<span id="more"></span>

<hr>
<style>
    .image{min-width: 400px}
    img{object-fit: scale-down}
</style>

<h2 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a>DBSCAN算法</h2><p><strong>DBSCAN</strong>（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的空间聚类方法）算法将点集中具有足够密度的区域划分为不同的簇，簇可以为任意形状，定义为密度相连点的最大集合。</p>
<p><strong>算法实现过程：</strong><br>在点集中任选一点，找到距该点距离 ≤ eps 的所有点。<br>若其数目 &lt; min_samples，则该点标记为噪声；<br>反之标记为核心样本点，并分配一个新的簇标签。<br>然后访问该点在距离 eps 以内的所有邻居：<br>若其未被分配簇，则分配新的簇标签；若其为核心样本点，则依次访问其邻居。<br>以此类推，直到在簇内各核心样本点的 eps 距离内无更多的核心样本点为止。<br>之后选取另一个未被访问的点，并重复以上相同的过程。</p>
<img class="image" src="img.png" width="60%" alt="pic1">

<h3 id="Traj-DBSCAN算法"><a href="#Traj-DBSCAN算法" class="headerlink" title="Traj-DBSCAN算法"></a>Traj-DBSCAN算法</h3><p>Traj-DBSCAN算法出自论文：Robust and Hierarchical Stop Discovery in Sparse and Diverse Trajectories.</p>
<p>其在DBSCAN的基础上，将邻居的计算从空间相邻改为时间线性相邻，而核心点计算则用停留时间代替周边点的数目。</p>
<p>TrajDBSCAN实现了“停留点集是子轨迹”的要求，其子轨迹内部所有点在空间上邻近，距离中心点小于距离阈值Eps，且子轨迹持续时长高于时间阈值MinTime，因此判断为轨迹在该处停留。</p>
<img class="image" src="img_1.png" width=75% alt="pic2">

<p>在此基础上，Traj-DBSCAN还实现了识别多条轨迹的“公共停留点”以及层次化停留点分析。</p>
<hr>
<h2 id="CB-SMoT算法"><a href="#CB-SMoT算法" class="headerlink" title="CB-SMoT算法"></a>CB-SMoT算法</h2><p>取自论文：A Clustering-based Approach for Discovering Interesting Places in Trajectories</p>
<p>先前的停留点挖掘思路通常要根据预定义的停留区来做停留检测，而该文则提出了一种基于速度的时空聚类方法，识别轨迹中的慢速区域，从而实现对轨迹上重要位置的挖掘。</p>
<p>下图中的ABC是已知的候选停留点，而XY是实际停留但未标记出的的位置。</p>
<img class="image" src="img_2.png" width="75%" alt="pic3">

<p>CB-SMoT算法是DBSCAN聚类算法的改进，有很多概念类似（如核心点、密度直达、密度可达等），其与DBSCAN的不同之处在于对邻域与核心点的定义不同。</p>
<p><strong>CB-SMoT对邻域定义如下：</strong></p>
<img class="image" src="img_3.png" width="100%" alt="pic4">

<p><strong>核心点(Core Point)定义：</strong><br>点集中的某一点，其Eps线性邻域内的轨迹持续时长高于时间阈值MinTime。该定义的本质上是实现了速度限制条件。</p>
<h3 id="算法实现方式"><a href="#算法实现方式" class="headerlink" title="算法实现方式"></a>算法实现方式</h3><p>1、首先判断该点是否被处理过，若未处理则计算在阈值距离内的邻域点集合，并标记该点为处理过；<br>2、判断该邻域点形成的子轨迹的持续时间是否超过阈值，若是则该点加入核心点集；<br>3、对于该核心点的邻域点集中的其他未处理点重复步骤1-2，同时扩充相应的邻域点集、核心点集，邻域点集内所有点都处理完毕；<br>4、将核心点集加入驻留点集中，重新回到步骤1，直到所有点都处理完毕。</p>
<ul>
<li>input: Track Point Series <code>&#123;Track_df&#125;</code>, Time Threshold <code>Min_Time</code>, Distance Threshold <code>Distance</code></li>
<li>output: Set of Stationary Points <code>&#123;Track_Stops&#125;</code></li>
</ul>
<img class="image" src="img_4.png" width="75%" alt="pic5">

<p><strong>具体python实现代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用CB-SMoT算法对轨迹的停留点进行提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cbSMoT_cluster</span>(<span class="params">track_df: pd.DataFrame, distance: <span class="built_in">float</span>, min_time: <span class="built_in">float</span></span>):</span><br><span class="line">    X = track_df[[<span class="string">&#x27;timestamp&#x27;</span>, <span class="string">&quot;lng&quot;</span>, <span class="string">&quot;lat&quot;</span>]]    <span class="comment"># 设置聚类基于的属性</span></span><br><span class="line">    track_stops = <span class="built_in">set</span>()             <span class="comment"># 用于保留最终的停留点集</span></span><br><span class="line">    process = np.zeros(<span class="built_in">len</span>(X))      <span class="comment"># 存储当前点是否被处理过</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X)):         <span class="comment"># 对于轨迹中的所有点</span></span><br><span class="line">        <span class="keyword">if</span> process[i] == <span class="number">0</span>:         <span class="comment"># 如果该点未被处理：</span></span><br><span class="line">            <span class="comment"># 计算该点的线性邻居（基于给定的距离），并标记为处理过</span></span><br><span class="line">            min_Pi, max_Pi = compute_linear_neighbours(X, i, distance)</span><br><span class="line">            Neighbour = <span class="built_in">set</span>(<span class="built_in">range</span>(min_Pi, max_Pi + <span class="number">1</span>))</span><br><span class="line">            process[i] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果停留时间超过阈值</span></span><br><span class="line">            <span class="keyword">if</span> compute_time(X.iloc[max_Pi], X.iloc[min_Pi]) &gt;= min_time:</span><br><span class="line">                cluster = &#123;i&#125;               <span class="comment"># 该点加入核心点集</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> Neighbour:         <span class="comment"># 对该邻域点集中的其他未处理点重复上述步骤</span></span><br><span class="line">                    <span class="keyword">if</span> process[j] == <span class="number">0</span>:     <span class="comment"># 如果该点未被处理：</span></span><br><span class="line">                        cluster.union(&#123;j&#125;)  <span class="comment"># 扩充相应的核心点集</span></span><br><span class="line">                        <span class="comment"># 计算该点的线性邻居</span></span><br><span class="line">                        min_Pj, max_Pj = compute_linear_neighbours(X, i, distance)</span><br><span class="line">                        Neighbour_1 = <span class="built_in">set</span>(<span class="built_in">range</span>(min_Pj, max_Pj + <span class="number">1</span>))</span><br><span class="line">                        <span class="comment"># 如果停留时间超过阈值</span></span><br><span class="line">                        <span class="keyword">if</span> compute_time(X.iloc[max_Pj], X.iloc[min_Pj]) &gt;= min_time:</span><br><span class="line">                            <span class="comment"># 扩充相应的邻域点集</span></span><br><span class="line">                            Neighbour = Neighbour.union(Neighbour_1)</span><br><span class="line">                <span class="comment"># 将核心点集加入驻留点集中</span></span><br><span class="line">                track_stops = track_stops.union(cluster)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 直到所有点都处理完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(track_stops)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找与路径点Ti的累计轨迹距离在D以内的近邻</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_linear_neighbours</span>(<span class="params">track_df: pd.DataFrame, index: <span class="built_in">int</span>, distance: <span class="built_in">float</span></span>):</span><br><span class="line">    <span class="comment"># 初始起终路径点</span></span><br><span class="line">    min_index, max_index = <span class="number">0</span>, <span class="built_in">len</span>(track_df) - <span class="number">1</span></span><br><span class="line">    total_dis = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 计算最小路径点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算相邻点之间的距离</span></span><br><span class="line">        dis = compute_distance(track_df.iloc[i], track_df.iloc[i-<span class="number">1</span>])</span><br><span class="line">        total_dis += dis</span><br><span class="line">        <span class="comment"># 如果小于距离阈值则继续，否则终止循环并记录最小路径点</span></span><br><span class="line">        <span class="keyword">if</span> total_dis &lt;= distance: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            min_index = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 计算最大路径点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(track_df) - <span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算相邻点之间的距离</span></span><br><span class="line">        dis = compute_distance(track_df.iloc[i], track_df.iloc[i+<span class="number">1</span>])</span><br><span class="line">        total_dis += dis</span><br><span class="line">        <span class="comment"># 如果小于距离阈值则继续，否则终止循环并记录最小路径点</span></span><br><span class="line">        <span class="keyword">if</span> total_dis &lt;= distance: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_index = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> min_index, max_index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算两点之间欧氏距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_distance</span>(<span class="params">tp1, tp2</span>):</span><br><span class="line">    dis = ((tp1.lng - tp2.lng) ** <span class="number">2</span> + (tp1.lat - tp2.lat) ** <span class="number">2</span>) ** <span class="number">0.5</span></span><br><span class="line">    <span class="keyword">return</span> dis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算两点之间时间差</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_time</span>(<span class="params">tp1, tp2</span>):</span><br><span class="line">    <span class="keyword">return</span> tp1.timestamp - tp2.timestamp</span><br></pre></td></tr></table></figure>

<h3 id="计算轨迹的平均路径点移动距离与停留时间"><a href="#计算轨迹的平均路径点移动距离与停留时间" class="headerlink" title="计算轨迹的平均路径点移动距离与停留时间"></a>计算轨迹的平均路径点移动距离与停留时间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算平均打点时间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mean_point_time</span>(<span class="params">track_df: pd.DataFrame</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(track_df)</span><br><span class="line">    time_arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>):</span><br><span class="line">        local_time = compute_time(track_df.iloc[i+<span class="number">1</span>], track_df.iloc[i])</span><br><span class="line">        time_arr = np.append(time_arr, local_time)</span><br><span class="line">    mean_value = data_mean(time_arr)</span><br><span class="line">    <span class="keyword">return</span> mean_value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均移动距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mean_point_distance</span>(<span class="params">track_df: pd.DataFrame</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(track_df)</span><br><span class="line">    distance_arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>):</span><br><span class="line">        local_distance = compute_distance(track_df.iloc[i+<span class="number">1</span>], track_df.iloc[i])</span><br><span class="line">        distance_arr = np.append(distance_arr, local_distance)</span><br><span class="line">    mean_value = data_mean(distance_arr)</span><br><span class="line">    <span class="keyword">return</span> mean_value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算数组的三个标准差内均值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_mean</span>(<span class="params">data_arr: np.array</span>):</span><br><span class="line">    mean = np.mean(data_arr, axis=<span class="number">0</span>)</span><br><span class="line">    std = np.std(data_arr, axis=<span class="number">0</span>)</span><br><span class="line">    data_array_proc = [x <span class="keyword">for</span> x <span class="keyword">in</span> data_arr <span class="keyword">if</span> (x &gt; mean-<span class="number">3</span>*std) &amp; (x &lt; mean+<span class="number">3</span>*std)]</span><br><span class="line">    mean_proc = np.mean(data_array_proc, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> mean_proc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
</search>
